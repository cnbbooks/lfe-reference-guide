# Predefined LFE functions

The following more or less standard lisp functions are predefined:

## Operators

### Arithmetic

```lisp
(<arith_op> expr ...)
```
The standard arithmetic operators, ``+`` ``-`` ``*`` and ``/`` can
take multiple arguments the same as their standard Lisp counterparts. 
This is still experimental and implemented using macros. They do,
however, behave like normal functions and evaluate ALL their
arguments before doing the arithmetic operations.

Examples:

```lisp
> (- 43 1)
42
> (* 21 2)
42
```

### Comparison

```lisp
(<comp_op> expr ...)
```
The standard comparison operators, ``>``, ``>=``, ``<``, ``=<``, ``==``,
``/=``, ``=:=``, and ``=/=`` can take multiple arguments the same as 
their standard Lisp counterparts. This is still experimental and 
implemented using macros. They do, however, behave like normal functions 
and evaluate ALL their arguments before doing the comparison
operations.

Examples:

```lisp
> (> 1 42)
false
> (< 42 43)
true
```

## Association list functions

These are the same as found in Common Lisp.

### ``acons``

```lisp
(acons key value list)
```

``acons`` constructs a new association list by adding the pair ``(key . datum)`` to the old ``list``. 

Example:

```lisp
> (acons 'x 'y 'a)
((x . y) . a)
```

### ``pairlis``

```lisp
(pairlis keys values {{list}})
```

``pairlis`` takes two lists and makes an association list that
associates elements of the first list to corresponding elements of
the second list.

Example:

```cl
> (pairlis '(one two) '(1 2) '((three . 3) (four . 19)))
((one . 1) (two . 2) (three . 3) (four . 19))
```

### ``assoc``

```lisp
(assoc key list)
```

Searches the association list ``list``. The value returned is the first 
pair in  the ``list`` such that the ``car`` of the pair equals the 
``key`` passed to ``assoc``. or ``()``  If there is no such pair in the 
``list``, an empty list ``()`` is returned.

Examples:

```lisp
> (assoc 'r '((a . b) (c . d) (r . x) (s . y) (r . z)))
(r . x)
> (assoc 'goo '((foo . bar) (zoo . goo)))
()
> (assoc '2 '((1 a b c) (2 b c d) (-7 x y z)))
(2 b c d)
>
```

### ``assoc-if``

```lisp
(assoc-if test list)
```

Searches the association list ``list``. The value is the first pair in 
the ``list`` such that the ``car`` of the pair satisfies the test, or 
``()``  if there is no such pair in the ``list``.

Examples:

```lisp
> (assoc-if #'is_atom/1 '(("a" . "b") (3 . 4) (r . x) (s . y) (r . z)))
(r . x)
> (assoc-if #'is_integer/1 '(("a" . "b") (3 . 4) (r . x) (s . y) (r . z)))
(3 . 4)
> (assoc-if #'is_list/1 '(("a" . "b") (3 . 4) (r . x) (s . y) (r . z)))
("a" 98)
> (assoc-if #'is_float/1 '(("a" . "b") (3 . 4) (r . x) (s . y) (r . z)))
()
```

### ``assoc-if-not``

```lisp
(assoc-if-not test list)
```

Searches the association list ``list``. The value is the first pair in 
the ``list`` such that the ``car`` of the pair satisfies the test, or 
``()``  if there is no such pair in the ``list``.

Examples:

```lisp
> (assoc-if-not #'is_float/1 '(("a" . "b") (3 . 4) (r . x) (s . y) (r . z)))
("a" 98)
> (assoc-if-not #'is_list/1 '(("a" . "b") (3 . 4) (r . x) (s . y) (r . z)))
(3 . 4)
```

### ``rassoc``

```lisp
(rassoc value list)
```

``rassoc`` is the reverse form of ``assoc``; it searches for a pair
whose ``cdr`` satisfies the ``test``, rather than the ``car``.

Examples:

```lisp
> (rassoc 'a '(("a" . "b") (r . 4) (3 . x) (s . y) (r . z)))
()
> (rassoc '4 '(("a" . "b") (r . 4) (3 . x) (s . y) (r . z)))
(r . 4)
> (rassoc 'z '(("a" . "b") (r . 4) (3 . x) (s . y) (r . z)))
(r . z)
```

### ``rassoc-if``

```lisp
(rassoc-if test list)
```

``rassoc`` is the reverse form of ``assoc``; it searches for a pair
whose ``cdr`` satisfies the ``test``, rather than the ``car``.

Examples:

```lisp
> (rassoc-if #'is_atom/1 '(("a" . "b") (r . 4) (3 . x) (s . y) (r . z)))
(3 . x)
> (rassoc-if
    (lambda (x)
      (== x 'y))
    '(("a" . "b") (r . 4) (3 . x) (s . y) (r . z)))
(s . y)
```

### ``rassoc-if-not``

```lisp
(rassoc-if-not test list)
```

``rassoc`` is the reverse form of ``assoc``; it searches for a pair
whose ``cdr`` satisfies the ``test``, rather than the ``car``.

Example:

```lisp
> (rassoc-if-not
    (lambda (x)
      (or (is_list x) (is_integer x)))
    '(("a" . "b") (r . 4) (3 . x) (s . y) (r . z)))
(3 . x)
```

## Substitution of expressions

These are the same as found in Common Lisp.

### ``subst``

```lisp
(subst new old tree)
```

### ``subst-if``

```lisp
(subst-if new test tree)
```

### ``subst-if-not``

```lisp
(subst-if-not new test tree)
```

### ``subls``

```lisp
(sublis alist tree)
```

## Expansion macros

```lisp
(macroexpand-1 expr {{environment}})
```

If Expr is a macro call, does one round of expansion,
otherwise returns Expr.

```lisp
(macroexpand expr {{environment}})
```

Returns the expansion returned by calling macroexpand-1
repeatedly, starting with Expr, until the result is no longer
a macro call.
        
```lisp
(macroexpand-all expr {{environment}})
```

Returns the expansion from the expression where all macro
calls have been expanded with macroexpand.

**NOTE**: When no explicit environment is given ti the
macroexpand functions, then only the default built-in macros
will be expanded. Inside macros and in the shell, the variable
``$ENV`` is bound to the current macro environment.

## Evaluation

```lisp
(eval expr {{environment}})
```

Evaluate the expression ``expr``. Note that only the pre-defined
Lisp functions, erlang BIFs and exported functions can be
called. Also no local variables can be accessed. To access
local variables, the ``expr`` to be evaluated can be wrapped in a
``let`` defining these.

For example, if the data we wish to evaluate is in the variable
``expr`` and it assumes there is a local variable ``foo`` which it
needs to access, then we could evaluate it by calling:

```lisp
(eval `(let ((foo ,foo)) ,expr))
```